using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Simpllist.Attributes;
using Simpllist.Context;
using System;
using System.Linq;
using System.Threading;

namespace Simpllist.Generators;

[Generator(LanguageNames.CSharp)]
public class ModuleInformationGenerator : IIncrementalGenerator
{

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<TargetModuleInformationCaptureContext> provider = context.SyntaxProvider
            .CreateSyntaxProvider(SyntacticPredicate, SemanticTransform)
            .Where(static type => type is not null)
            .Select(static (type, _) => TransformType(type!))
            .WithComparer(TargetModuleInformationCaptureComparer.Instance);

        context.RegisterSourceOutput(provider, ModuleInformationExecution.Execute);
    }

    private static bool SyntacticPredicate(SyntaxNode node, CancellationToken cancellation)
    {
        return node is AttributeSyntax attribute &&
               attribute.Name.ToString().Contains(ModuleAssemblyAttribute.TypeName) &&
               attribute.Parent is AttributeListSyntax list &&
               list.Target?.Identifier.IsKind(SyntaxKind.AssemblyKeyword) == true;
    }

    private static TargetModuleInformationCaptureContext? SemanticTransform(GeneratorSyntaxContext context, CancellationToken cancellation)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        var moduleAssemblyAttribute = context.SemanticModel.Compilation.GetTypeByMetadataName(ModuleAssemblyAttribute.TypeFullName);

        if (moduleAssemblyAttribute is null)
        {
            return null;
        }

        var assemblyAttributes = context.SemanticModel.Compilation.Assembly.GetAttributes();

        var attrData = assemblyAttributes.FirstOrDefault(ad =>
            SymbolEqualityComparer.Default.Equals(ad.AttributeClass, moduleAssemblyAttribute));
  
        if (attrData == null)
        {
            return null;
        }

        return new TargetModuleInformationCaptureContext(GetValue(0), GetValue(1));

        // Local function to parse the value in the constructor argument list.
        string GetValue(int index) => attrData.ConstructorArguments.Length > index
            ? attrData.ConstructorArguments[index].Value?.ToString() ?? ""
            : "";
    }

    private static TargetModuleInformationCaptureContext TransformType(TargetModuleInformationCaptureContext informationCapture)
    {
        // TODO: Possibly remove, but we might need this at some point.
        return informationCapture;
    }
}


public class ModuleInformationExecution
{
    /// <summary>
    /// Writes the gathered information to the source code.
    /// </summary>
    /// <param name="context">Production</param>
    /// <param name="subject">Partial class gathered information</param>
    public static void Execute(SourceProductionContext context, TargetModuleInformationCaptureContext subject)
    {
        var moduleName = subject.ModuleName.Trim().Replace(' ', '_');
        var code = $@"
// <auto-generated/> @{DateTime.UtcNow}
namespace Simpllist.Wrapless
{{
    #nullable enable

    /// <summary>
    /// Code generated by reading the Assembly attribute
    /// </summary>
    //[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{Global.Namespace}"", ""{Global.Version}"")]
    public sealed class {moduleName}ModuleInformation : global::{Global.ModuleInterface}
    {{
        public string ModuleName {{ get; private set; }} = ""{subject.ModuleName}"";
        public string DealerName {{ get; private set; }} = ""{subject.DealerName}"";
    }}
}}
";
        context.AddSource($"{moduleName}.Simpllist.Module.g.cs", code);
    }

}