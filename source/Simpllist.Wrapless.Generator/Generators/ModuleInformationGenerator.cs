using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Simpllist.Attributes;
using Simpllist.Context;
using System;
using System.Linq;
using System.Threading;
using Simpllist.Interfaces;

namespace Simpllist.Generators;

[Generator(LanguageNames.CSharp)]
public class ModuleInformationGenerator : IIncrementalGenerator
{

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<TargetModuleInformationCaptureContext> provider = context.SyntaxProvider
            .CreateSyntaxProvider(SyntacticPredicate, SemanticTransform)
            .Where(static type => type is not null)
            .Select(static (type, _) => TransformType(type!))
            .WithComparer(TargetModuleInformationCaptureComparer.Instance);

        context.RegisterSourceOutput(provider, ModuleInformationExecution.Execute);
    }

    private static bool SyntacticPredicate(SyntaxNode node, CancellationToken cancellation)
    {
        return node is AttributeSyntax attribute &&
               attribute.Name.ToString().Contains(ModuleAssemblyAttribute.TypeName) &&
               attribute.Parent is AttributeListSyntax list &&
               list.Target?.Identifier.IsKind(SyntaxKind.AssemblyKeyword) == true;
    }

    private static TargetModuleInformationCaptureContext? SemanticTransform(GeneratorSyntaxContext context, CancellationToken cancellation)
    {
        var moduleAssemblyAttribute = context.SemanticModel.Compilation.GetTypeByMetadataName(ModuleAssemblyAttribute.TypeFullName);

        if (moduleAssemblyAttribute is null)
        {
            return null;
        }

        var assemblyAttributes = context.SemanticModel.Compilation.Assembly.GetAttributes();

        var attrData = assemblyAttributes.FirstOrDefault(ad => 
            SymbolEqualityComparer.Default.Equals(ad.AttributeClass, moduleAssemblyAttribute));
  
        if (attrData == null)
        {
            return null;
        }

        return new TargetModuleInformationCaptureContext(
            ModuleName: GetValue(0),
            DealerName: GetValue(1),
            SystemName: GetValue(2),
            Programmer: GetValue(3),
            Comments: GetValue(4),
            PdfHelpFile: GetValue(5));

        // Local function to parse the value in the constructor argument list.
        string GetValue(int index) => attrData.ConstructorArguments.Length > index
            ? attrData.ConstructorArguments[index].Value?.ToString() ?? ""
            : "";
    }

    private static TargetModuleInformationCaptureContext TransformType(TargetModuleInformationCaptureContext informationCapture)
    {
        // TODO: Possibly remove, but we might need this at some point.
        return informationCapture;
    }
}


public class ModuleInformationExecution
{
    /// <summary>
    /// Writes the gathered information to the source code.
    /// </summary>
    /// <param name="context">Production</param>
    /// <param name="subject">Partial class gathered information</param>
    public static void Execute(SourceProductionContext context, TargetModuleInformationCaptureContext subject)
    {
        var moduleName = subject.ModuleName.Trim().Replace(' ', '_');
        var code = $@"
// <auto-generated/> @{DateTime.UtcNow}
namespace Simpllist.Wrapless
{{
    #nullable enable

    /// <summary>
    /// Code generated by reading the Assembly attribute
    /// </summary>
    //[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{Global.Namespace}"", ""{Global.Version}"")]
    public sealed class {moduleName}ModuleInformation : global::{ModuleInformationInterface.TypeFullName}
    {{
        public string ModuleName {{ get; private set; }} = ""{subject.ModuleName}"";
        public string DealerName {{ get; private set; }} = ""{subject.DealerName}"";
        public string SystemName {{ get; private set; }} = ""{subject.SystemName}"";
        public string Programmer {{ get; private set; }} = ""{subject.Programmer}"";
        public string Comments {{ get; private set; }} = ""{subject.Comments}"";
        public string PdfHelpFile {{ get; private set; }} = ""{subject.PdfHelpFile}"";

        public global::System.Text.StringBuilder Builder {{ get; }} = new global::System.Text.StringBuilder()
            .AppendLine(""/*******************************************************************************************"")
            .AppendLine(""SIMPL+ Module Information"")
            .AppendLine(""*******************************************************************************************/"")
            .AppendLine(""/*"")
            .AppendLine(""Dealer Name: {subject.DealerName} "")
            .AppendLine(""System Name: {subject.SystemName}"")
            .AppendLine(""Programmer: {subject.Programmer}"")
            .AppendLine(""Comments: {subject.Comments}"")
            .AppendLine(""*/"");
    }}

    public static class ModuleInformation
    {{
        public static global::System.Text.StringBuilder ModuleHeaderBuilder = new global::System.Text.StringBuilder()
            .AppendLine(""/*******************************************************************************************"")
            .AppendLine(""SIMPL+ Module Information"")
            .AppendLine(""*******************************************************************************************/"")
            .AppendLine(""/*"")
            .AppendLine(""Dealer Name: {subject.DealerName} "")
            .AppendLine(""System Name: {subject.SystemName}"")
            .AppendLine(""Programmer: {subject.Programmer}"")
            .AppendLine(""Comments: {subject.Comments}"")
            .AppendLine(""*/"");
    }}
}}
";
        context.AddSource($"{moduleName}.Simpllist.Module.g.cs", code);
    }

}